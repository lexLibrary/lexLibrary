//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package irish

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "b'", A: -1, B: 4, F: nil},
	{Str: "bh", A: -1, B: 14, F: nil},
	{Str: "bhf", A: 1, B: 9, F: nil},
	{Str: "bp", A: -1, B: 11, F: nil},
	{Str: "ch", A: -1, B: 15, F: nil},
	{Str: "d'", A: -1, B: 2, F: nil},
	{Str: "d'fh", A: 5, B: 3, F: nil},
	{Str: "dh", A: -1, B: 16, F: nil},
	{Str: "dt", A: -1, B: 13, F: nil},
	{Str: "fh", A: -1, B: 17, F: nil},
	{Str: "gc", A: -1, B: 7, F: nil},
	{Str: "gh", A: -1, B: 18, F: nil},
	{Str: "h-", A: -1, B: 1, F: nil},
	{Str: "m'", A: -1, B: 4, F: nil},
	{Str: "mb", A: -1, B: 6, F: nil},
	{Str: "mh", A: -1, B: 19, F: nil},
	{Str: "n-", A: -1, B: 1, F: nil},
	{Str: "nd", A: -1, B: 8, F: nil},
	{Str: "ng", A: -1, B: 10, F: nil},
	{Str: "ph", A: -1, B: 20, F: nil},
	{Str: "sh", A: -1, B: 5, F: nil},
	{Str: "t-", A: -1, B: 1, F: nil},
	{Str: "th", A: -1, B: 21, F: nil},
	{Str: "ts", A: -1, B: 12, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "\u00EDochta", A: -1, B: 1, F: nil},
	{Str: "a\u00EDochta", A: 0, B: 1, F: nil},
	{Str: "ire", A: -1, B: 2, F: nil},
	{Str: "aire", A: 2, B: 2, F: nil},
	{Str: "abh", A: -1, B: 1, F: nil},
	{Str: "eabh", A: 4, B: 1, F: nil},
	{Str: "ibh", A: -1, B: 1, F: nil},
	{Str: "aibh", A: 6, B: 1, F: nil},
	{Str: "amh", A: -1, B: 1, F: nil},
	{Str: "eamh", A: 8, B: 1, F: nil},
	{Str: "imh", A: -1, B: 1, F: nil},
	{Str: "aimh", A: 10, B: 1, F: nil},
	{Str: "\u00EDocht", A: -1, B: 1, F: nil},
	{Str: "a\u00EDocht", A: 12, B: 1, F: nil},
	{Str: "ir\u00ED", A: -1, B: 2, F: nil},
	{Str: "air\u00ED", A: 14, B: 2, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "\u00F3ideacha", A: -1, B: 6, F: nil},
	{Str: "patacha", A: -1, B: 5, F: nil},
	{Str: "achta", A: -1, B: 1, F: nil},
	{Str: "arcachta", A: 2, B: 2, F: nil},
	{Str: "eachta", A: 2, B: 1, F: nil},
	{Str: "grafa\u00EDochta", A: -1, B: 4, F: nil},
	{Str: "paite", A: -1, B: 5, F: nil},
	{Str: "ach", A: -1, B: 1, F: nil},
	{Str: "each", A: 7, B: 1, F: nil},
	{Str: "\u00F3ideach", A: 8, B: 6, F: nil},
	{Str: "gineach", A: 8, B: 3, F: nil},
	{Str: "patach", A: 7, B: 5, F: nil},
	{Str: "grafa\u00EDoch", A: -1, B: 4, F: nil},
	{Str: "pataigh", A: -1, B: 5, F: nil},
	{Str: "\u00F3idigh", A: -1, B: 6, F: nil},
	{Str: "acht\u00FAil", A: -1, B: 1, F: nil},
	{Str: "eacht\u00FAil", A: 15, B: 1, F: nil},
	{Str: "gineas", A: -1, B: 3, F: nil},
	{Str: "ginis", A: -1, B: 3, F: nil},
	{Str: "acht", A: -1, B: 1, F: nil},
	{Str: "arcacht", A: 19, B: 2, F: nil},
	{Str: "eacht", A: 19, B: 1, F: nil},
	{Str: "grafa\u00EDocht", A: -1, B: 4, F: nil},
	{Str: "arcachta\u00ED", A: -1, B: 2, F: nil},
	{Str: "grafa\u00EDochta\u00ED", A: -1, B: 4, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "imid", A: -1, B: 1, F: nil},
	{Str: "aimid", A: 0, B: 1, F: nil},
	{Str: "\u00EDmid", A: -1, B: 1, F: nil},
	{Str: "a\u00EDmid", A: 2, B: 1, F: nil},
	{Str: "adh", A: -1, B: 2, F: nil},
	{Str: "eadh", A: 4, B: 2, F: nil},
	{Str: "faidh", A: -1, B: 1, F: nil},
	{Str: "fidh", A: -1, B: 1, F: nil},
	{Str: "\u00E1il", A: -1, B: 2, F: nil},
	{Str: "ain", A: -1, B: 2, F: nil},
	{Str: "tear", A: -1, B: 2, F: nil},
	{Str: "tar", A: -1, B: 2, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 4, 2}

type Context struct {
	i_p2 int
	i_p1 int
	i_pV int
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 28
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	// do, line 34
	var v_1 = env.Cursor
lab0:
	for {
		// (, line 34
		// gopast, line 35
	golab1:
		for {
		lab2:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab2
				}
				break golab1
			}
			if env.Cursor >= env.Limit {
				break lab0
			}
			env.NextChar()
		}
		// setmark pV, line 35
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	// do, line 37
	var v_3 = env.Cursor
lab3:
	for {
		// (, line 37
		// gopast, line 38
	golab4:
		for {
		lab5:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab5
				}
				break golab4
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
		// gopast, line 38
	golab6:
		for {
		lab7:
			for {
				if !env.OutGrouping(G_v, 97, 250) {
					break lab7
				}
				break golab6
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
		// setmark p1, line 38
		context.i_p1 = env.Cursor
		// gopast, line 39
	golab8:
		for {
		lab9:
			for {
				if !env.InGrouping(G_v, 97, 250) {
					break lab9
				}
				break golab8
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
		// gopast, line 39
	golab10:
		for {
		lab11:
			for {
				if !env.OutGrouping(G_v, 97, 250) {
					break lab11
				}
				break golab10
			}
			if env.Cursor >= env.Limit {
				break lab3
			}
			env.NextChar()
		}
		// setmark p2, line 39
		context.i_p2 = env.Cursor
		break lab3
	}
	env.Cursor = v_3
	return true
}

func r_initial_morph(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 43
	// [, line 44
	env.Bra = env.Cursor
	// substring, line 44
	among_var = env.FindAmong(A_0, context)
	if among_var == 0 {
		return false
	}
	// ], line 44
	env.Ket = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 46
		// delete, line 46
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 50
		// delete, line 50
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 3 {
		// (, line 52
		// <-, line 52
		if !env.SliceFrom("f") {
			return false
		}
	} else if among_var == 4 {
		// (, line 55
		// delete, line 55
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 5 {
		// (, line 58
		// <-, line 58
		if !env.SliceFrom("s") {
			return false
		}
	} else if among_var == 6 {
		// (, line 61
		// <-, line 61
		if !env.SliceFrom("b") {
			return false
		}
	} else if among_var == 7 {
		// (, line 63
		// <-, line 63
		if !env.SliceFrom("c") {
			return false
		}
	} else if among_var == 8 {
		// (, line 65
		// <-, line 65
		if !env.SliceFrom("d") {
			return false
		}
	} else if among_var == 9 {
		// (, line 67
		// <-, line 67
		if !env.SliceFrom("f") {
			return false
		}
	} else if among_var == 10 {
		// (, line 69
		// <-, line 69
		if !env.SliceFrom("g") {
			return false
		}
	} else if among_var == 11 {
		// (, line 71
		// <-, line 71
		if !env.SliceFrom("p") {
			return false
		}
	} else if among_var == 12 {
		// (, line 73
		// <-, line 73
		if !env.SliceFrom("s") {
			return false
		}
	} else if among_var == 13 {
		// (, line 75
		// <-, line 75
		if !env.SliceFrom("t") {
			return false
		}
	} else if among_var == 14 {
		// (, line 79
		// <-, line 79
		if !env.SliceFrom("b") {
			return false
		}
	} else if among_var == 15 {
		// (, line 81
		// <-, line 81
		if !env.SliceFrom("c") {
			return false
		}
	} else if among_var == 16 {
		// (, line 83
		// <-, line 83
		if !env.SliceFrom("d") {
			return false
		}
	} else if among_var == 17 {
		// (, line 85
		// <-, line 85
		if !env.SliceFrom("f") {
			return false
		}
	} else if among_var == 18 {
		// (, line 87
		// <-, line 87
		if !env.SliceFrom("g") {
			return false
		}
	} else if among_var == 19 {
		// (, line 89
		// <-, line 89
		if !env.SliceFrom("m") {
			return false
		}
	} else if among_var == 20 {
		// (, line 91
		// <-, line 91
		if !env.SliceFrom("p") {
			return false
		}
	} else if among_var == 21 {
		// (, line 93
		// <-, line 93
		if !env.SliceFrom("t") {
			return false
		}
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_noun_sfx(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 103
	// [, line 104
	env.Ket = env.Cursor
	// substring, line 104
	among_var = env.FindAmongB(A_1, context)
	if among_var == 0 {
		return false
	}
	// ], line 104
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 108
		// call R1, line 108
		if !r_R1(env, context) {
			return false
		}
		// delete, line 108
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 110
		// call R2, line 110
		if !r_R2(env, context) {
			return false
		}
		// delete, line 110
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_deriv(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 113
	// [, line 114
	env.Ket = env.Cursor
	// substring, line 114
	among_var = env.FindAmongB(A_2, context)
	if among_var == 0 {
		return false
	}
	// ], line 114
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 116
		// call R2, line 116
		if !r_R2(env, context) {
			return false
		}
		// delete, line 116
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 118
		// <-, line 118
		if !env.SliceFrom("arc") {
			return false
		}
	} else if among_var == 3 {
		// (, line 120
		// <-, line 120
		if !env.SliceFrom("gin") {
			return false
		}
	} else if among_var == 4 {
		// (, line 122
		// <-, line 122
		if !env.SliceFrom("graf") {
			return false
		}
	} else if among_var == 5 {
		// (, line 124
		// <-, line 124
		if !env.SliceFrom("paite") {
			return false
		}
	} else if among_var == 6 {
		// (, line 126
		// <-, line 126
		if !env.SliceFrom("\u00F3id") {
			return false
		}
	}
	return true
}

func r_verb_sfx(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 129
	// [, line 130
	env.Ket = env.Cursor
	// substring, line 130
	among_var = env.FindAmongB(A_3, context)
	if among_var == 0 {
		return false
	}
	// ], line 130
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 133
		// call RV, line 133
		if !r_RV(env, context) {
			return false
		}
		// delete, line 133
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 138
		// call R1, line 138
		if !r_R1(env, context) {
			return false
		}
		// delete, line 138
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	// (, line 143
	// do, line 144
	var v_1 = env.Cursor
lab0:
	for {
		// call initial_morph, line 144
		if !r_initial_morph(env, context) {
			break lab0
		}
		break lab0
	}
	env.Cursor = v_1
	// do, line 145
	var v_2 = env.Cursor
lab1:
	for {
		// call mark_regions, line 145
		if !r_mark_regions(env, context) {
			break lab1
		}
		break lab1
	}
	env.Cursor = v_2
	// backwards, line 146
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	// (, line 146
	// do, line 147
	var v_3 = env.Limit - env.Cursor
lab2:
	for {
		// call noun_sfx, line 147
		if !r_noun_sfx(env, context) {
			break lab2
		}
		break lab2
	}
	env.Cursor = env.Limit - v_3
	// do, line 148
	var v_4 = env.Limit - env.Cursor
lab3:
	for {
		// call deriv, line 148
		if !r_deriv(env, context) {
			break lab3
		}
		break lab3
	}
	env.Cursor = env.Limit - v_4
	// do, line 149
	var v_5 = env.Limit - env.Cursor
lab4:
	for {
		// call verb_sfx, line 149
		if !r_verb_sfx(env, context) {
			break lab4
		}
		break lab4
	}
	env.Cursor = env.Limit - v_5
	env.Cursor = env.LimitBackward
	return true
}
